
load "./types.maude" .

mod OPERATOR is

  sorts Operator Category .

  op category : Operator -> Category .

endm

mod EXPRESSION is

  pr TYPE .
  pr OPERATOR .

  sorts Expression .

  op type : Expression -> Type .

endm

mod LITERAL-EXPRESSION is

  pr EXPRESSION .

  sort Literal .

  subsort Literal < Expression .

  op True : -> Literal .
  op False : -> Literal .

  pr PRIMITIVE-TYPES .

  eq type(True) = Boolean .
  eq type(False) = Boolean .

  pr NUMERIC-TYPES .
  pr QID .

  sort IntegerLiteral .
  subsort IntegerLiteral < Literal .
  op _i : Qid -> IntegerLiteral .
  var I : IntegerLiteral .
  eq type(I) = Integer .

  sort LongLiteral .
  subsort LongLiteral < Literal .
  op _l : Qid -> LongLiteral .
  var L : LongLiteral .
  eq type(L) = Long .

endm

mod INFIX-EXPRESSION is

  pr EXPRESSION .

  sort Infix .

  subsort Infix < Expression .

  op (_ _ _) : Expression Operator Expression -> Infix .

endm

mod LOGICAL-EXPRESSION is

  pr INFIX-EXPRESSION .

  op Logical : -> Category .

  ops and or : -> Operator .

  eq category(and) = Logical .
  eq category(or) = Logical .

  vars E1 E2 : Expression .
  var OP : Operator .

  pr BOOLEAN-TYPE .

  op logical : Expression Operator Expression -> Bool .
  eq logical(E1, OP, E2) = type(E1) == Boolean and type(E2) == Boolean and
                           category(OP) == Logical .

  ceq type(E1 OP E2) = Boolean if logical(E1, OP, E2) .

  pr UNDEFINED-TYPE .

  op InvalidLogicalExpression : -> TypeError .

  ceq type(E1 OP E2) = Undefined(InvalidLogicalExpression)
    if not logical(E1, OP, E2) and category(OP) == Logical .

endm

mod ARITHMETIC-EXPRESSION is

  pr INFIX-EXPRESSION .

  op Arithmetic : -> Category .

  ops + - / * : -> Operator .

  eq category(+) = Arithmetic .
  eq category(-) = Arithmetic .
  eq category(/) = Arithmetic .
  eq category(*) = Arithmetic .

  vars E1 E2 : Expression .
  var OP : Operator .

  op arithmetic : Expression Operator Expression -> Bool .
  eq arithmetic(E1, OP, E2) = numeric(type(E1)) and numeric(type(E2)) and
                              category(OP) == Arithmetic .

  pr NUMERIC-TYPES .

  ceq type(E1 OP E2) = type(E2)
    if arithmetic(E1, OP, E2) and type(E1) <= type(E2) .

  ceq type(E1 OP E2) = type(E1)
     if arithmetic(E1, OP, E2) and type(E2) <= type(E1) .

  pr UNDEFINED-TYPE .

  op InvalidArithmeticExpression : -> TypeError .

  ceq type(E1 OP E2) = Undefined(InvalidArithmeticExpression)
    if not arithmetic(E1, OP, E2) and category(OP) == Arithmetic .

endm

mod UNDEFINED-EXPRESSION is

  pr TYPE .

  op NotInferred : -> TypeError .

  pr EXPRESSION .
  pr UNDEFINED-TYPE .

  eq type(E:Expression) = Undefined(NotInferred) .

endm

mod EXPRESSIONS is
  pr LITERAL-EXPRESSION .
  pr LOGICAL-EXPRESSION .
  pr ARITHMETIC-EXPRESSION .
  pr UNDEFINED-EXPRESSION .
endm
