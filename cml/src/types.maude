
mod TYPE is
  sorts Type .

  op _<:_ : Type Type -> Bool .
  var T : Type .
  eq T <: T = true .

  op _<:>_ : Type Type -> Bool .
  var X Y Z : Type .
  eq X <:> Y = X <: Y or Y <: X .

  sorts TypeError .
  op Undefined : TypeError -> Type .
endm

mod BOOLEAN-TYPE is
  pr TYPE .

  sort BooleanType .
  subsort BooleanType < Type .

  op Boolean : -> BooleanType .
endm

mod NUMERIC-TYPES is
  pr TYPE .

  sort NumericType .
  subsort NumericType < Type .

  op Byte : -> NumericType .
  op Short : -> NumericType .
  op Integer : -> NumericType .
  op Long : -> NumericType .
  op Decimal : -> NumericType .

  op numeric : Type -> Bool .

  var T1 : NumericType .
  eq numeric(T1) = true .

  var T2 : Type .
  eq numeric(T2) = false .

  eq Byte <: Short = true .
  eq Short <: Integer = true .
  eq Integer <: Long = true .
  eq Long <: Decimal = true .
endm

mod FLOATING-POINT-TYPES is
  pr TYPE .

  sort FloatingPointType .
  subsort FloatingPointType < Type .

  op Float : -> FloatingPointType .
  op Double : -> FloatingPointType .

  op floating_point : Type -> Bool .

  var T1 : FloatingPointType .
  eq floating_point(T1) = true .

  var T2 : Type .
  eq floating_point(T2) = false .

  eq Float <: Double = true .
endm

mod STRING-TYPE is
  pr TYPE .
  op String : -> Type .
endm

mod PRIMITIVE-TYPES is
  pr BOOLEAN-TYPE .
  pr NUMERIC-TYPES .
  pr FLOATING-POINT-TYPES .
  pr STRING-TYPE .
endm

mod SEQUENTIAL-TYPE is
  pr TYPE .

  sorts SequentialType .
  subsorts SequentialType < Type .

  op _? : Type -> SequentialType .
  op _* : Type -> SequentialType .

  sort Cardinality .

  op zero : -> Cardinality .
  op one : -> Cardinality .
  op many : -> Cardinality .

  var T : Type .

  op minCardinality : SequentialType -> Cardinality .
  eq minCardinality(T ?) = zero .
  eq minCardinality(T *) = zero .
  eq minCardinality(T) = one .

  op maxCardinality : SequentialType -> Cardinality .
  eq maxCardinality(T ?) = one .
  eq maxCardinality(T *) = many .
  eq maxCardinality(T) = one .

  var T1 T2 : SequentialType .

  op matchCardinality : SequentialType SequentialType -> Bool .
  eq matchCardinality(T1, T2) = minCardinality(T1) == minCardinality(T2) and
                                maxCardinality(T1) == maxCardinality(T2) .
endm

mod REFERENTIAL-TYPE is
  pr SEQUENTIAL-TYPE .

  sort ReferentialType .
  subsort ReferentialType < SequentialType .

  var T : Type .

  op InvalidSequentialTypeDeclaration : -> TypeError .
  ceq T ? = Undefined(InvalidSequentialTypeDeclaration)
    if not (T :: ReferentialType) .
  ceq T * = Undefined(InvalidSequentialTypeDeclaration)
    if not (T :: ReferentialType) .

  op elementaryTypeOf : Type -> ReferentialType .
  ceq elementaryTypeOf(T) = T if T :: ReferentialType .
  ceq elementaryTypeOf(T ?) = T if T :: ReferentialType .
  ceq elementaryTypeOf(T *) = T if T :: ReferentialType .
endm

mod TYPES is
  pr PRIMITIVE-TYPES .
  pr SEQUENTIAL-TYPE .
  pr REFERENTIAL-TYPE .
endm
